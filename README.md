# Алгоритмы и структуры данных - Лабораторная №2.1 - Вариант №16

Лабораторная работа состоит из двух заданий, которые должны быть выполнены на одном из трёх уровней сложности. Уровень сложности выбирается обучающимся самостоятельно.

**Задание 1.** Реализовать  алгоритмы  сортировки  согласно  своему  варианту  и  уровню сложности. Реализуемые сортировки определяются цифрами представления вашего номера варианта в системе счисления по основанию 3.


|**Группа 1**|**Группа 2**|**Группа 3 (только для среднего и высокого уровня сложности)**|
| - | - | - |
|<p>0. Сортировка пузырьком</p><p>1. Сортировка вставками</p><p>2. Сортировка выбором</p>|<p>0. Сортировка Шелла</p><p>1. Шейкерная сортировка</p><p>2. Быстрая сортировка</p>|<p>0. Сортировка расчёской</p><p>1. Сортировка естественным двухпутевым слиянием (naturial two-way merge sort)</p><p>2. Пирамидальная сортировка</p>|

**Пример.** Допустимый набор вариантов 0—26 (000 3—222 3). Предположим, что вам назначен вариант 19. Представим это число в системе счисления с основанием 3: 19 = 2 ·32 + 0·31 + 1·30 = 201 . Таким образом, в 19-ом варианте необходимо реализовать: 3

*на минимальном уровне сложности:*

- сортировку выбором (2);
- сортировку Шелла (0);

*на среднем и высоком уровне сложности:*

- сортировку выбором (2);
- сортировку Шелла (0);
- сортировку естественным двухпутевым слиянием (1).

**Задание 2.** Посчитать число сравнений и число копирований объектов для массивов длины 1 000, 2 000, 3 000, …, 10 000:

а) в среднем (сгенерировать 100 случайных массивов и посчитать среднее значение); б) для полностью отсортированного массива;

в) для обратно отсортированного массива.

По полученным данным построить графики, сравнить экспериментальные результаты с теорией, сделать выводы.

**Минимальный уровень сложности**

1. Реализовать два алгоритма сортировки (из первой и второй групп) согласно своему варианту.
1. Запрещено  использование  указателей,  любых  функций  из  **<algorithm>**  и  любых контейнеров стандартной библиотеки (см. исключение в пункте 3).
1. Разрешается завести один или более дополнительных экземпляров  **std::vector<int>** — но только при условии, что они действительно необходимы.
4. Публичные профили функций должны выглядеть так (например, для 19-го варианта):

```cpp

struct stats 
{
  size_t comparison_count = 0;
  size_t copy_count       = 0; 
};

stats selection_sort (std::vector<int>& data); 
stats     shell_sort (std::vector<int>& data);

```

Для других вариантов по-другому будут выглядеть  только названия  функций (выделены жирным цветом). Возвращаемый тип и входной аргумент для любой функции сортировки из любого варианта должны в точности совпадать с приведённым выше примером.

**Средний уровень сложности**

Реализовать третий алгоритм сортировки (из третьей группы) согласно своему варианту.

Например, для 19-го варианта профили функций будут выглядеть так: 

```cpp

stats     selection_sort (std::vector<int>& data);
stats         shell_sort (std::vector<int>& data); 
stats two_way_merge_sort (std::vector<int>& data);

```

**Высокий уровень сложности**

В дополнение к требованиям среднего уровня сложности:

1. Функции  должны  быть  шаблонными  и  абстрагированными  от  механизма  сравнения. Публичные профили функций должны выглядеть так (например, для 19 варианта):

```cpp

template<typename T, typename TCompare = std::less<T>>
stats     selection_sort (std::vector<T>& data);

template<typename T, typename TCompare = std::less<T>>
stats         shell_sort (std::vector<T>& data);

template<typename T, typename TCompare = std::less<T>>
stats two_way_merge_sort (std::vector<T>& data);

```

2. Построить  графики  зависимости  количества  проведённых  сравнений  от  количества элементов  в  массиве.  **Графики  должны  совпадать  с  предсказаниями  теории.**  При необходимости искусственно замедлить операцию сравнения, предоставив собственный компаратор  с  **std::this\_thread::sleep\_for** .  Разрешается  по  своему  усмотрению скорректировать размеры массивов для получения адекватного времени замера.
